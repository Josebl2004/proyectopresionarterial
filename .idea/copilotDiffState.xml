<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/proyectopresionarterial/AddRecordViewModel.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/proyectopresionarterial/AddRecordViewModel.java" />
              <option name="originalContent" value="package com.example.proyectopresionarterial;&#10;&#10;import android.app.Application;&#10;import android.content.Context;&#10;import android.net.ConnectivityManager;&#10;import android.net.Network;&#10;import android.net.NetworkCapabilities;&#10;&#10;import androidx.annotation.NonNull;&#10;import androidx.lifecycle.AndroidViewModel;&#10;import androidx.lifecycle.LiveData;&#10;import androidx.lifecycle.MutableLiveData;&#10;&#10;import java.text.SimpleDateFormat;&#10;import java.util.Date;&#10;import java.util.Locale;&#10;import java.util.concurrent.ExecutorService;&#10;import java.util.concurrent.Executors;&#10;&#10;public class AddRecordViewModel extends AndroidViewModel {&#10;&#10;    private final AppDatabase db;&#10;    private final ExecutorService executor = Executors.newSingleThreadExecutor();&#10;&#10;    private final MutableLiveData&lt;String&gt; errorMessage = new MutableLiveData&lt;&gt;();&#10;    private final MutableLiveData&lt;Boolean&gt; saveSuccess = new MutableLiveData&lt;&gt;();&#10;    private final MutableLiveData&lt;String&gt; infoMessage = new MutableLiveData&lt;&gt;();&#10;    private final MutableLiveData&lt;BloodPressureRecord&gt; record = new MutableLiveData&lt;&gt;();&#10;&#10;    public AddRecordViewModel(@NonNull Application application) {&#10;        super(application);&#10;        db = AppDatabase.getInstance(application);&#10;    }&#10;&#10;    public LiveData&lt;String&gt; getErrorMessage() { return errorMessage; }&#10;    public LiveData&lt;Boolean&gt; getSaveSuccess() { return saveSuccess; }&#10;    public LiveData&lt;String&gt; getInfoMessage() { return infoMessage; }&#10;    public LiveData&lt;BloodPressureRecord&gt; getRecord() { return record; }&#10;&#10;    public void saveRecord(String systolicStr, String diastolicStr, String heartRateStr, String condition) {&#10;        // Validaciones básicas de vacío&#10;        if (isEmpty(systolicStr) || isEmpty(diastolicStr) || isEmpty(heartRateStr) || isEmpty(condition)) {&#10;            errorMessage.postValue(&quot;Completa todos los campos obligatorios&quot;);&#10;            return;&#10;        }&#10;&#10;        int systolic, diastolic, heartRate;&#10;        try {&#10;            systolic = Integer.parseInt(systolicStr);&#10;            diastolic = Integer.parseInt(diastolicStr);&#10;            heartRate = Integer.parseInt(heartRateStr);&#10;        } catch (NumberFormatException e) {&#10;            errorMessage.postValue(&quot;Ingresa valores numéricos válidos&quot;);&#10;            return;&#10;        }&#10;&#10;        // Rangos&#10;        if (systolic &lt; 50 || systolic &gt; 250) {&#10;            errorMessage.postValue(&quot;Sistólica debe estar entre 50 y 250&quot;);&#10;            return;&#10;        }&#10;        if (diastolic &lt; 30 || diastolic &gt; 150) {&#10;            errorMessage.postValue(&quot;Diastólica debe estar entre 30 y 150&quot;);&#10;            return;&#10;        }&#10;        if (heartRate &lt; 30 || heartRate &gt; 200) {&#10;            errorMessage.postValue(&quot;Frecuencia cardíaca debe estar entre 30 y 200&quot;);&#10;            return;&#10;        }&#10;&#10;        // Construir el registro con fecha/hora actuales&#10;        final BloodPressureRecord newRecord = new BloodPressureRecord();&#10;        String date = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.US).format(new Date());&#10;        String time = new SimpleDateFormat(&quot;HH:mm&quot;, Locale.US).format(new Date());&#10;        newRecord.setDate(date);&#10;        newRecord.setTime(time);&#10;        newRecord.setSystolic(systolic);&#10;        newRecord.setDiastolic(diastolic);&#10;        newRecord.setHeartRate(heartRate);&#10;        newRecord.setCondition(condition.toLowerCase(Locale.ROOT));&#10;        // Clasificación local inmediata&#10;        newRecord.setClassification(ClassificationHelper.classify(systolic, diastolic));&#10;        newRecord.setSynced(false);&#10;&#10;        executor.execute(() -&gt; {&#10;            try {&#10;                long id = db.bloodPressureDao().insert(newRecord);&#10;                newRecord.setId(id);&#10;&#10;                if (!hasInternet()) {&#10;                    infoMessage.postValue(&quot;Guardado localmente. Se sincronizará cuando haya conexión&quot;);&#10;                }&#10;&#10;                saveSuccess.postValue(true);&#10;&#10;                // Webhook n8n: evento de creación (con recomendación si es posible)&#10;                postToWebhookWithRecommendation(newRecord, &quot;created&quot;);&#10;&#10;                // Intentar sincronizar con la API si hay internet (no bloquea la UI)&#10;                syncRecord(newRecord);&#10;            } catch (Exception e) {&#10;                errorMessage.postValue(&quot;Error al guardar: &quot; + e.getMessage());&#10;                saveSuccess.postValue(false);&#10;            }&#10;        });&#10;    }&#10;&#10;    // Método sobrecargado para guardar con fecha y hora específicas&#10;    public void saveRecord(String systolicStr, String diastolicStr, String heartRateStr,&#10;                         String condition, String time, String date, String notes) {&#10;        // Validaciones básicas de vacío&#10;        if (isEmpty(systolicStr) || isEmpty(diastolicStr) || isEmpty(heartRateStr) || isEmpty(condition)) {&#10;            errorMessage.postValue(&quot;Completa todos los campos obligatorios&quot;);&#10;            return;&#10;        }&#10;&#10;        int systolic, diastolic, heartRate;&#10;        try {&#10;            systolic = Integer.parseInt(systolicStr);&#10;            diastolic = Integer.parseInt(diastolicStr);&#10;            heartRate = Integer.parseInt(heartRateStr);&#10;        } catch (NumberFormatException e) {&#10;            errorMessage.postValue(&quot;Ingresa valores numéricos válidos&quot;);&#10;            return;&#10;        }&#10;&#10;        // Rangos&#10;        if (systolic &lt; 50 || systolic &gt; 250) {&#10;            errorMessage.postValue(&quot;Sistólica debe estar entre 50 y 250&quot;);&#10;            return;&#10;        }&#10;        if (diastolic &lt; 30 || diastolic &gt; 150) {&#10;            errorMessage.postValue(&quot;Diastólica debe estar entre 30 y 150&quot;);&#10;            return;&#10;        }&#10;        if (heartRate &lt; 30 || heartRate &gt; 200) {&#10;            errorMessage.postValue(&quot;Frecuencia cardíaca debe estar entre 30 y 200&quot;);&#10;            return;&#10;        }&#10;&#10;        // Construir el registro con la fecha y hora proporcionadas&#10;        final BloodPressureRecord newRecord = new BloodPressureRecord();&#10;        newRecord.setDate(date);&#10;        newRecord.setTime(time);&#10;        newRecord.setSystolic(systolic);&#10;        newRecord.setDiastolic(diastolic);&#10;        newRecord.setHeartRate(heartRate);&#10;        newRecord.setCondition(condition.toLowerCase(Locale.ROOT));&#10;        // Nota: El parámetro notes se ignora porque BloodPressureRecord no tiene ese campo&#10;        // Clasificación local inmediata&#10;        newRecord.setClassification(ClassificationHelper.classify(systolic, diastolic));&#10;        newRecord.setSynced(false);&#10;&#10;        executor.execute(() -&gt; {&#10;            try {&#10;                long id = db.bloodPressureDao().insert(newRecord);&#10;                newRecord.setId(id);&#10;&#10;                if (!hasInternet()) {&#10;                    infoMessage.postValue(&quot;Guardado localmente. Se sincronizará cuando haya conexión&quot;);&#10;                }&#10;&#10;                saveSuccess.postValue(true);&#10;&#10;                // Webhook n8n: evento de creación (con recomendación si es posible)&#10;                postToWebhookWithRecommendation(newRecord, &quot;created&quot;);&#10;&#10;                // Intentar sincronizar con la API si hay internet (no bloquea la UI)&#10;                syncRecord(newRecord);&#10;            } catch (Exception e) {&#10;                errorMessage.postValue(&quot;Error al guardar: &quot; + e.getMessage());&#10;                saveSuccess.postValue(false);&#10;            }&#10;        });&#10;    }&#10;&#10;    // Método para cargar un registro existente&#10;    public void loadRecord(long recordId) {&#10;        if (recordId &lt;= 0) {&#10;            errorMessage.postValue(&quot;ID de registro inválido&quot;);&#10;            return;&#10;        }&#10;&#10;        executor.execute(() -&gt; {&#10;            try {&#10;                BloodPressureRecord loadedRecord = db.bloodPressureDao().getById(recordId);&#10;                if (loadedRecord != null) {&#10;                    record.postValue(loadedRecord);&#10;                } else {&#10;                    errorMessage.postValue(&quot;No se encontró el registro&quot;);&#10;                }&#10;            } catch (Exception e) {&#10;                errorMessage.postValue(&quot;Error al cargar: &quot; + e.getMessage());&#10;            }&#10;        });&#10;    }&#10;&#10;    // Método para actualizar un registro existente&#10;    public void updateRecord(long recordId, String systolicStr, String diastolicStr, String heartRateStr,&#10;                           String condition, String time, String date, String notes) {&#10;        // Validaciones básicas de vacío&#10;        if (isEmpty(systolicStr) || isEmpty(diastolicStr) || isEmpty(heartRateStr) || isEmpty(condition)) {&#10;            errorMessage.postValue(&quot;Completa todos los campos obligatorios&quot;);&#10;            return;&#10;        }&#10;&#10;        int systolic, diastolic, heartRate;&#10;        try {&#10;            systolic = Integer.parseInt(systolicStr);&#10;            diastolic = Integer.parseInt(diastolicStr);&#10;            heartRate = Integer.parseInt(heartRateStr);&#10;        } catch (NumberFormatException e) {&#10;            errorMessage.postValue(&quot;Ingresa valores numéricos válidos&quot;);&#10;            return;&#10;        }&#10;&#10;        // Rangos&#10;        if (systolic &lt; 50 || systolic &gt; 250) {&#10;            errorMessage.postValue(&quot;Sistólica debe estar entre 50 y 250&quot;);&#10;            return;&#10;        }&#10;        if (diastolic &lt; 30 || diastolic &gt; 150) {&#10;            errorMessage.postValue(&quot;Diastólica debe estar entre 30 y 150&quot;);&#10;            return;&#10;        }&#10;        if (heartRate &lt; 30 || heartRate &gt; 200) {&#10;            errorMessage.postValue(&quot;Frecuencia cardíaca debe estar entre 30 y 200&quot;);&#10;            return;&#10;        }&#10;&#10;        executor.execute(() -&gt; {&#10;            try {&#10;                BloodPressureRecord existingRecord = db.bloodPressureDao().getById(recordId);&#10;                if (existingRecord != null) {&#10;                    existingRecord.setSystolic(systolic);&#10;                    existingRecord.setDiastolic(diastolic);&#10;                    existingRecord.setHeartRate(heartRate);&#10;                    existingRecord.setCondition(condition.toLowerCase(Locale.ROOT));&#10;                    existingRecord.setTime(time);&#10;                    existingRecord.setDate(date);&#10;                    existingRecord.setClassification(ClassificationHelper.classify(systolic, diastolic));&#10;                    existingRecord.setSynced(false);&#10;&#10;                    db.bloodPressureDao().update(existingRecord);&#10;&#10;                    if (!hasInternet()) {&#10;                        infoMessage.postValue(&quot;Actualizado localmente. Se sincronizará cuando haya conexión&quot;);&#10;                    }&#10;&#10;                    saveSuccess.postValue(true);&#10;&#10;                    // Webhook n8n: evento de actualización (con recomendación si es posible)&#10;                    postToWebhookWithRecommendation(existingRecord, &quot;updated&quot;);&#10;&#10;                    // Intentar sincronizar con la API si hay internet&#10;                    syncRecord(existingRecord);&#10;                } else {&#10;                    errorMessage.postValue(&quot;No se encontró el registro a actualizar&quot;);&#10;                    saveSuccess.postValue(false);&#10;                }&#10;            } catch (Exception e) {&#10;                errorMessage.postValue(&quot;Error al actualizar: &quot; + e.getMessage());&#10;                saveSuccess.postValue(false);&#10;            }&#10;        });&#10;    }&#10;&#10;    // Método para eliminar un registro&#10;    public void deleteRecord(long recordId) {&#10;        if (recordId &lt;= 0) {&#10;            errorMessage.postValue(&quot;ID de registro inválido&quot;);&#10;            return;&#10;        }&#10;&#10;        executor.execute(() -&gt; {&#10;            try {&#10;                BloodPressureRecord recordToDelete = db.bloodPressureDao().getById(recordId);&#10;                if (recordToDelete != null) {&#10;                    db.bloodPressureDao().delete(recordToDelete);&#10;                    saveSuccess.postValue(true);&#10;&#10;                    // Webhook n8n: evento de eliminación (sin recomendación)&#10;                    postToWebhook(recordToDelete, &quot;deleted&quot;);&#10;&#10;                    // Si el registro estaba sincronizado, notificar a la API&#10;                    if (recordToDelete.isSynced() &amp;&amp; hasInternet()) {&#10;                        // Aquí iría la llamada a la API para eliminar el registro en el servidor&#10;                    }&#10;                } else {&#10;                    errorMessage.postValue(&quot;No se encontró el registro a eliminar&quot;);&#10;                    saveSuccess.postValue(false);&#10;                }&#10;            } catch (Exception e) {&#10;                errorMessage.postValue(&quot;Error al eliminar: &quot; + e.getMessage());&#10;                saveSuccess.postValue(false);&#10;            }&#10;        });&#10;    }&#10;&#10;    private boolean isEmpty(String s) {&#10;        return s == null || s.trim().isEmpty();&#10;    }&#10;&#10;    private boolean hasInternet() {&#10;        ConnectivityManager cm = (ConnectivityManager) getApplication().getSystemService(Context.CONNECTIVITY_SERVICE);&#10;        if (cm == null) return false;&#10;&#10;        Network activeNetwork = cm.getActiveNetwork();&#10;        if (activeNetwork == null) return false;&#10;&#10;        NetworkCapabilities capabilities = cm.getNetworkCapabilities(activeNetwork);&#10;        return capabilities != null &amp;&amp;&#10;               (capabilities.hasTransport(NetworkCapabilities.TRANSPORT_WIFI) ||&#10;                capabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR));&#10;    }&#10;&#10;    private void syncRecord(BloodPressureRecord record) {&#10;        // Aquí iría la implementación de sincronización con la API&#10;    }&#10;&#10;    // Enviar al webhook si hay internet y está configurado (sin recomendación explícita)&#10;    private void postToWebhook(BloodPressureRecord r, String event) {&#10;        try {&#10;            if (r == null) return;&#10;            if (hasInternet()) {&#10;                N8nWebhookClient.sendRecordAsync(getApplication(), r, event);&#10;            }&#10;        } catch (Exception ignored) {}&#10;    }&#10;&#10;    // Enviar al webhook, intentando primero obtener una recomendación corta de la API&#10;    private void postToWebhookWithRecommendation(BloodPressureRecord r, String event) {&#10;        if (r == null) return;&#10;        if (!hasInternet()) {&#10;            // Sin internet: enviar sin recomendación ni intento de API&#10;            postToWebhook(r, event);&#10;            return;&#10;        }&#10;        try {&#10;            RecommendationFetcher.fetchForRecord(getApplication(), r, new RecommendationFetcher.RecCallback() {&#10;                @Override&#10;                public void onSuccess(String recommendation) {&#10;                    try {&#10;                        N8nWebhookClient.sendRecordAsync(getApplication(), r, event, recommendation);&#10;                    } catch (Exception ignored) {}&#10;                }&#10;&#10;                @Override&#10;                public void onError(String message) {&#10;                    // Fallback: enviar sin recomendación&#10;                    postToWebhook(r, event);&#10;                }&#10;            });&#10;        } catch (Exception e) {&#10;            // Fallback: enviar sin recomendación si algo falla&#10;            postToWebhook(r, event);&#10;        }&#10;    }&#10;&#10;    public void syncPendingRecords() {&#10;        // Método para sincronizar todos los registros pendientes&#10;        if (!hasInternet()) {&#10;            return; // No hay internet, no intentar sincronizar&#10;        }&#10;&#10;        executor.execute(() -&gt; {&#10;            try {&#10;                // Obtener todos los registros no sincronizados&#10;                // List&lt;BloodPressureRecord&gt; pendingRecords = db.bloodPressureDao().getUnsyncedRecords();&#10;                // for (BloodPressureRecord record : pendingRecords) {&#10;                //     syncRecord(record);&#10;                // }&#10;                // Por ahora, este método no hace nada porque no tenemos la implementación completa de la API&#10;            } catch (Exception e) {&#10;                // Log del error si es necesario&#10;            }&#10;        });&#10;    }&#10;&#10;    @Override&#10;    protected void onCleared() {&#10;        super.onCleared();&#10;        executor.shutdown();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.proyectopresionarterial;&#10;&#10;import android.app.Application;&#10;import android.content.Context;&#10;import android.net.ConnectivityManager;&#10;import android.net.Network;&#10;import android.net.NetworkCapabilities;&#10;import android.util.Log;&#10;&#10;import androidx.annotation.NonNull;&#10;import androidx.lifecycle.AndroidViewModel;&#10;import androidx.lifecycle.LiveData;&#10;import androidx.lifecycle.MutableLiveData;&#10;&#10;import java.text.SimpleDateFormat;&#10;import java.util.Date;&#10;import java.util.Locale;&#10;import java.util.concurrent.ExecutorService;&#10;import java.util.concurrent.Executors;&#10;&#10;public class AddRecordViewModel extends AndroidViewModel {&#10;&#10;    private static final String TAG = &quot;AddRecordVM&quot;;&#10;&#10;    private final AppDatabase db;&#10;    private final ExecutorService executor = Executors.newSingleThreadExecutor();&#10;&#10;    private final MutableLiveData&lt;String&gt; errorMessage = new MutableLiveData&lt;&gt;();&#10;    private final MutableLiveData&lt;Boolean&gt; saveSuccess = new MutableLiveData&lt;&gt;();&#10;    private final MutableLiveData&lt;String&gt; infoMessage = new MutableLiveData&lt;&gt;();&#10;    private final MutableLiveData&lt;BloodPressureRecord&gt; record = new MutableLiveData&lt;&gt;();&#10;&#10;    public AddRecordViewModel(@NonNull Application application) {&#10;        super(application);&#10;        db = AppDatabase.getInstance(application);&#10;    }&#10;&#10;    public LiveData&lt;String&gt; getErrorMessage() { return errorMessage; }&#10;    public LiveData&lt;Boolean&gt; getSaveSuccess() { return saveSuccess; }&#10;    public LiveData&lt;String&gt; getInfoMessage() { return infoMessage; }&#10;    public LiveData&lt;BloodPressureRecord&gt; getRecord() { return record; }&#10;&#10;    public void saveRecord(String systolicStr, String diastolicStr, String heartRateStr, String condition) {&#10;        // Validaciones básicas de vacío&#10;        if (isEmpty(systolicStr) || isEmpty(diastolicStr) || isEmpty(heartRateStr) || isEmpty(condition)) {&#10;            errorMessage.postValue(&quot;Completa todos los campos obligatorios&quot;);&#10;            return;&#10;        }&#10;&#10;        int systolic, diastolic, heartRate;&#10;        try {&#10;            systolic = Integer.parseInt(systolicStr);&#10;            diastolic = Integer.parseInt(diastolicStr);&#10;            heartRate = Integer.parseInt(heartRateStr);&#10;        } catch (NumberFormatException e) {&#10;            errorMessage.postValue(&quot;Ingresa valores numéricos válidos&quot;);&#10;            return;&#10;        }&#10;&#10;        // Rangos&#10;        if (systolic &lt; 50 || systolic &gt; 250) {&#10;            errorMessage.postValue(&quot;Sistólica debe estar entre 50 y 250&quot;);&#10;            return;&#10;        }&#10;        if (diastolic &lt; 30 || diastolic &gt; 150) {&#10;            errorMessage.postValue(&quot;Diastólica debe estar entre 30 y 150&quot;);&#10;            return;&#10;        }&#10;        if (heartRate &lt; 30 || heartRate &gt; 200) {&#10;            errorMessage.postValue(&quot;Frecuencia cardíaca debe estar entre 30 y 200&quot;);&#10;            return;&#10;        }&#10;&#10;        // Construir el registro con fecha/hora actuales&#10;        final BloodPressureRecord newRecord = new BloodPressureRecord();&#10;        String date = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.US).format(new Date());&#10;        String time = new SimpleDateFormat(&quot;HH:mm&quot;, Locale.US).format(new Date());&#10;        newRecord.setDate(date);&#10;        newRecord.setTime(time);&#10;        newRecord.setSystolic(systolic);&#10;        newRecord.setDiastolic(diastolic);&#10;        newRecord.setHeartRate(heartRate);&#10;        newRecord.setCondition(condition.toLowerCase(Locale.ROOT));&#10;        // Clasificación local inmediata&#10;        newRecord.setClassification(ClassificationHelper.classify(systolic, diastolic));&#10;        newRecord.setSynced(false);&#10;&#10;        executor.execute(() -&gt; {&#10;            try {&#10;                long id = db.bloodPressureDao().insert(newRecord);&#10;                newRecord.setId(id);&#10;&#10;                if (!hasInternet()) {&#10;                    infoMessage.postValue(&quot;Guardado localmente. Se sincronizará cuando haya conexión&quot;);&#10;                }&#10;&#10;                saveSuccess.postValue(true);&#10;&#10;                // Webhook n8n: evento de creación (con recomendación si es posible)&#10;                Log.d(TAG, &quot;Webhook: encolando evento 'created' para id=&quot; + newRecord.getId());&#10;                postToWebhookWithRecommendation(newRecord, &quot;created&quot;);&#10;&#10;                // Intentar sincronizar con la API si hay internet (no bloquea la UI)&#10;                syncRecord(newRecord);&#10;            } catch (Exception e) {&#10;                errorMessage.postValue(&quot;Error al guardar: &quot; + e.getMessage());&#10;                saveSuccess.postValue(false);&#10;            }&#10;        });&#10;    }&#10;&#10;    // Método sobrecargado para guardar con fecha y hora específicas&#10;    public void saveRecord(String systolicStr, String diastolicStr, String heartRateStr,&#10;                         String condition, String time, String date, String notes) {&#10;        // Validaciones básicas de vacío&#10;        if (isEmpty(systolicStr) || isEmpty(diastolicStr) || isEmpty(heartRateStr) || isEmpty(condition)) {&#10;            errorMessage.postValue(&quot;Completa todos los campos obligatorios&quot;);&#10;            return;&#10;        }&#10;&#10;        int systolic, diastolic, heartRate;&#10;        try {&#10;            systolic = Integer.parseInt(systolicStr);&#10;            diastolic = Integer.parseInt(diastolicStr);&#10;            heartRate = Integer.parseInt(heartRateStr);&#10;        } catch (NumberFormatException e) {&#10;            errorMessage.postValue(&quot;Ingresa valores numéricos válidos&quot;);&#10;            return;&#10;        }&#10;&#10;        // Rangos&#10;        if (systolic &lt; 50 || systolic &gt; 250) {&#10;            errorMessage.postValue(&quot;Sistólica debe estar entre 50 y 250&quot;);&#10;            return;&#10;        }&#10;        if (diastolic &lt; 30 || diastolic &gt; 150) {&#10;            errorMessage.postValue(&quot;Diastólica debe estar entre 30 y 150&quot;);&#10;            return;&#10;        }&#10;        if (heartRate &lt; 30 || heartRate &gt; 200) {&#10;            errorMessage.postValue(&quot;Frecuencia cardíaca debe estar entre 30 y 200&quot;);&#10;            return;&#10;        }&#10;&#10;        // Construir el registro con la fecha y hora proporcionadas&#10;        final BloodPressureRecord newRecord = new BloodPressureRecord();&#10;        newRecord.setDate(date);&#10;        newRecord.setTime(time);&#10;        newRecord.setSystolic(systolic);&#10;        newRecord.setDiastolic(diastolic);&#10;        newRecord.setHeartRate(heartRate);&#10;        newRecord.setCondition(condition.toLowerCase(Locale.ROOT));&#10;        // Nota: El parámetro notes se ignora porque BloodPressureRecord no tiene ese campo&#10;        // Clasificación local inmediata&#10;        newRecord.setClassification(ClassificationHelper.classify(systolic, diastolic));&#10;        newRecord.setSynced(false);&#10;&#10;        executor.execute(() -&gt; {&#10;            try {&#10;                long id = db.bloodPressureDao().insert(newRecord);&#10;                newRecord.setId(id);&#10;&#10;                if (!hasInternet()) {&#10;                    infoMessage.postValue(&quot;Guardado localmente. Se sincronizará cuando haya conexión&quot;);&#10;                }&#10;&#10;                saveSuccess.postValue(true);&#10;&#10;                // Webhook n8n: evento de creación (con recomendación si es posible)&#10;                Log.d(TAG, &quot;Webhook: encolando evento 'created' (custom datetime) para id=&quot; + newRecord.getId());&#10;                postToWebhookWithRecommendation(newRecord, &quot;created&quot;);&#10;&#10;                // Intentar sincronizar con la API si hay internet (no bloquea la UI)&#10;                syncRecord(newRecord);&#10;            } catch (Exception e) {&#10;                errorMessage.postValue(&quot;Error al guardar: &quot; + e.getMessage());&#10;                saveSuccess.postValue(false);&#10;            }&#10;        });&#10;    }&#10;&#10;    // Método para cargar un registro existente&#10;    public void loadRecord(long recordId) {&#10;        if (recordId &lt;= 0) {&#10;            errorMessage.postValue(&quot;ID de registro inválido&quot;);&#10;            return;&#10;        }&#10;&#10;        executor.execute(() -&gt; {&#10;            try {&#10;                BloodPressureRecord loadedRecord = db.bloodPressureDao().getById(recordId);&#10;                if (loadedRecord != null) {&#10;                    record.postValue(loadedRecord);&#10;                } else {&#10;                    errorMessage.postValue(&quot;No se encontró el registro&quot;);&#10;                }&#10;            } catch (Exception e) {&#10;                errorMessage.postValue(&quot;Error al cargar: &quot; + e.getMessage());&#10;            }&#10;        });&#10;    }&#10;&#10;    // Método para actualizar un registro existente&#10;    public void updateRecord(long recordId, String systolicStr, String diastolicStr, String heartRateStr,&#10;                           String condition, String time, String date, String notes) {&#10;        // Validaciones básicas de vacío&#10;        if (isEmpty(systolicStr) || isEmpty(diastolicStr) || isEmpty(heartRateStr) || isEmpty(condition)) {&#10;            errorMessage.postValue(&quot;Completa todos los campos obligatorios&quot;);&#10;            return;&#10;        }&#10;&#10;        int systolic, diastolic, heartRate;&#10;        try {&#10;            systolic = Integer.parseInt(systolicStr);&#10;            diastolic = Integer.parseInt(diastolicStr);&#10;            heartRate = Integer.parseInt(heartRateStr);&#10;        } catch (NumberFormatException e) {&#10;            errorMessage.postValue(&quot;Ingresa valores numéricos válidos&quot;);&#10;            return;&#10;        }&#10;&#10;        // Rangos&#10;        if (systolic &lt; 50 || systolic &gt; 250) {&#10;            errorMessage.postValue(&quot;Sistólica debe estar entre 50 y 250&quot;);&#10;            return;&#10;        }&#10;        if (diastolic &lt; 30 || diastolic &gt; 150) {&#10;            errorMessage.postValue(&quot;Diastólica debe estar entre 30 y 150&quot;);&#10;            return;&#10;        }&#10;        if (heartRate &lt; 30 || heartRate &gt; 200) {&#10;            errorMessage.postValue(&quot;Frecuencia cardíaca debe estar entre 30 y 200&quot;);&#10;            return;&#10;        }&#10;&#10;        executor.execute(() -&gt; {&#10;            try {&#10;                BloodPressureRecord existingRecord = db.bloodPressureDao().getById(recordId);&#10;                if (existingRecord != null) {&#10;                    existingRecord.setSystolic(systolic);&#10;                    existingRecord.setDiastolic(diastolic);&#10;                    existingRecord.setHeartRate(heartRate);&#10;                    existingRecord.setCondition(condition.toLowerCase(Locale.ROOT));&#10;                    existingRecord.setTime(time);&#10;                    existingRecord.setDate(date);&#10;                    existingRecord.setClassification(ClassificationHelper.classify(systolic, diastolic));&#10;                    existingRecord.setSynced(false);&#10;&#10;                    db.bloodPressureDao().update(existingRecord);&#10;&#10;                    if (!hasInternet()) {&#10;                        infoMessage.postValue(&quot;Actualizado localmente. Se sincronizará cuando haya conexión&quot;);&#10;                    }&#10;&#10;                    saveSuccess.postValue(true);&#10;&#10;                    // Webhook n8n: evento de actualización (con recomendación si es posible)&#10;                    Log.d(TAG, &quot;Webhook: encolando evento 'updated' para id=&quot; + existingRecord.getId());&#10;                    postToWebhookWithRecommendation(existingRecord, &quot;updated&quot;);&#10;&#10;                    // Intentar sincronizar con la API si hay internet&#10;                    syncRecord(existingRecord);&#10;                } else {&#10;                    errorMessage.postValue(&quot;No se encontró el registro a actualizar&quot;);&#10;                    saveSuccess.postValue(false);&#10;                }&#10;            } catch (Exception e) {&#10;                errorMessage.postValue(&quot;Error al actualizar: &quot; + e.getMessage());&#10;                saveSuccess.postValue(false);&#10;            }&#10;        });&#10;    }&#10;&#10;    // Método para eliminar un registro&#10;    public void deleteRecord(long recordId) {&#10;        if (recordId &lt;= 0) {&#10;            errorMessage.postValue(&quot;ID de registro inválido&quot;);&#10;            return;&#10;        }&#10;&#10;        executor.execute(() -&gt; {&#10;            try {&#10;                BloodPressureRecord recordToDelete = db.bloodPressureDao().getById(recordId);&#10;                if (recordToDelete != null) {&#10;                    db.bloodPressureDao().delete(recordToDelete);&#10;                    saveSuccess.postValue(true);&#10;&#10;                    // Webhook n8n: evento de eliminación (sin recomendación)&#10;                    Log.d(TAG, &quot;Webhook: encolando evento 'deleted' para id=&quot; + recordToDelete.getId());&#10;                    postToWebhook(recordToDelete, &quot;deleted&quot;);&#10;&#10;                    // Si el registro estaba sincronizado, notificar a la API&#10;                    if (recordToDelete.isSynced() &amp;&amp; hasInternet()) {&#10;                        // Aquí iría la llamada a la API para eliminar el registro en el servidor&#10;                    }&#10;                } else {&#10;                    errorMessage.postValue(&quot;No se encontró el registro a eliminar&quot;);&#10;                    saveSuccess.postValue(false);&#10;                }&#10;            } catch (Exception e) {&#10;                errorMessage.postValue(&quot;Error al eliminar: &quot; + e.getMessage());&#10;                saveSuccess.postValue(false);&#10;            }&#10;        });&#10;    }&#10;&#10;    private boolean isEmpty(String s) {&#10;        return s == null || s.trim().isEmpty();&#10;    }&#10;&#10;    private boolean hasInternet() {&#10;        ConnectivityManager cm = (ConnectivityManager) getApplication().getSystemService(Context.CONNECTIVITY_SERVICE);&#10;        if (cm == null) return false;&#10;&#10;        Network activeNetwork = cm.getActiveNetwork();&#10;        if (activeNetwork == null) return false;&#10;&#10;        NetworkCapabilities capabilities = cm.getNetworkCapabilities(activeNetwork);&#10;        return capabilities != null &amp;&amp;&#10;               (capabilities.hasTransport(NetworkCapabilities.TRANSPORT_WIFI) ||&#10;                capabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR));&#10;    }&#10;&#10;    private void syncRecord(BloodPressureRecord record) {&#10;        // Aquí iría la implementación de sincronización con la API&#10;    }&#10;&#10;    // Enviar al webhook si hay internet y está configurado (sin recomendación explícita)&#10;    private void postToWebhook(BloodPressureRecord r, String event) {&#10;        try {&#10;            if (r == null) return;&#10;            if (hasInternet()) {&#10;                Log.d(TAG, &quot;Webhook: enviando sin recomendación, event=&quot; + event + &quot;, id=&quot; + r.getId());&#10;                N8nWebhookClient.sendRecordAsync(getApplication(), r, event);&#10;            } else {&#10;                Log.w(TAG, &quot;Webhook: sin internet, no se envía. event=&quot; + event + &quot;, id=&quot; + r.getId());&#10;            }&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Webhook: error postToWebhook: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    // Enviar al webhook, intentando primero obtener una recomendación corta de la API&#10;    private void postToWebhookWithRecommendation(BloodPressureRecord r, String event) {&#10;        if (r == null) return;&#10;        if (!hasInternet()) {&#10;            // Sin internet: generar recomendación local y enviar&#10;            String localRec = RecommendationLocal.generate(r);&#10;            Log.w(TAG, &quot;Webhook: sin internet, envío con recomendación local. event=&quot; + event + &quot;, id=&quot; + (r != null ? r.getId() : -1));&#10;            try {&#10;                N8nWebhookClient.sendRecordAsync(getApplication(), r, event, localRec);&#10;            } catch (Exception e) {&#10;                Log.e(TAG, &quot;Webhook: error al enviar recomendación local sin internet: &quot; + e.getMessage());&#10;            }&#10;            return;&#10;        }&#10;        try {&#10;            RecommendationFetcher.fetchForRecord(getApplication(), r, new RecommendationFetcher.RecCallback() {&#10;                @Override&#10;                public void onSuccess(String recommendation) {&#10;                    try {&#10;                        Log.d(TAG, &quot;Webhook: enviando con recomendación API. event=&quot; + event + &quot;, id=&quot; + r.getId());&#10;                        N8nWebhookClient.sendRecordAsync(getApplication(), r, event, recommendation);&#10;                    } catch (Exception e) {&#10;                        Log.e(TAG, &quot;Webhook: error al enviar con recomendación API: &quot; + e.getMessage());&#10;                    }&#10;                }&#10;&#10;                @Override&#10;                public void onError(String message) {&#10;                    // Fallback: generar y enviar recomendación local personalizada&#10;                    String localRec = RecommendationLocal.generate(r);&#10;                    Log.w(TAG, &quot;Webhook: fallo recomendación API ('&quot; + message + &quot;'), envío con recomendación local. event=&quot; + event + &quot;, id=&quot; + r.getId());&#10;                    try {&#10;                        N8nWebhookClient.sendRecordAsync(getApplication(), r, event, localRec);&#10;                    } catch (Exception e) {&#10;                        Log.e(TAG, &quot;Webhook: error al enviar con recomendación local: &quot; + e.getMessage());&#10;                        // Último fallback: envío básico sin recomendación&#10;                        postToWebhook(r, event);&#10;                    }&#10;                }&#10;            });&#10;        } catch (Exception e) {&#10;            // Fallback: generar y enviar recomendación local si algo falla&#10;            String localRec = RecommendationLocal.generate(r);&#10;            Log.e(TAG, &quot;Webhook: excepción al obtener recomendación API, envío con recomendación local. event=&quot; + event + &quot;, id=&quot; + r.getId() + &quot;. Error: &quot; + e.getMessage());&#10;            try {&#10;                N8nWebhookClient.sendRecordAsync(getApplication(), r, event, localRec);&#10;            } catch (Exception ex) {&#10;                Log.e(TAG, &quot;Webhook: error al enviar con recomendación local tras excepción: &quot; + ex.getMessage());&#10;                postToWebhook(r, event);&#10;            }&#10;        }&#10;    }&#10;&#10;    public void syncPendingRecords() {&#10;        // Método para sincronizar todos los registros pendientes&#10;        if (!hasInternet()) {&#10;            return; // No hay internet, no intentar sincronizar&#10;        }&#10;&#10;        executor.execute(() -&gt; {&#10;            try {&#10;                // Obtener todos los registros no sincronizados&#10;                // List&lt;BloodPressureRecord&gt; pendingRecords = db.bloodPressureDao().getUnsyncedRecords();&#10;                // for (BloodPressureRecord record : pendingRecords) {&#10;                //     syncRecord(record);&#10;                // }&#10;                // Por ahora, este método no hace nada porque no tenemos la implementación completa de la API&#10;            } catch (Exception e) {&#10;                // Log del error si es necesario&#10;                Log.e(TAG, &quot;syncPendingRecords error: &quot; + e.getMessage());&#10;            }&#10;        });&#10;    }&#10;&#10;    @Override&#10;    protected void onCleared() {&#10;        super.onCleared();&#10;        executor.shutdown();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/proyectopresionarterial/N8nWebhookClient.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/proyectopresionarterial/N8nWebhookClient.java" />
              <option name="originalContent" value="package com.example.proyectopresionarterial;&#10;&#10;import android.app.Application;&#10;import android.text.TextUtils;&#10;import android.util.Log;&#10;&#10;import com.google.gson.Gson;&#10;import com.google.gson.annotations.SerializedName;&#10;&#10;import java.util.Locale;&#10;&#10;import okhttp3.Call;&#10;import okhttp3.Callback;&#10;import okhttp3.MediaType;&#10;import okhttp3.OkHttpClient;&#10;import okhttp3.Request;&#10;import okhttp3.RequestBody;&#10;import okhttp3.Response;&#10;import java.io.IOException;&#10;&#10;/**&#10; * Cliente minimalista para enviar eventos al webhook de n8n.&#10; * Configurar en res/values/strings.xml el valor de n8n_webhook_url con el link del webhook.&#10; */&#10;public final class N8nWebhookClient {&#10;&#10;    private static final String TAG = &quot;N8nWebhook&quot;;&#10;    private static final MediaType JSON = MediaType.parse(&quot;application/json; charset=utf-8&quot;);&#10;&#10;    private static final OkHttpClient client = new OkHttpClient.Builder()&#10;            .retryOnConnectionFailure(true)&#10;            .build();&#10;&#10;    private static final Gson gson = new Gson();&#10;&#10;    private N8nWebhookClient() {}&#10;&#10;    /**&#10;     * Compatibilidad hacia atrás: envía sin recomendación.&#10;     */&#10;    public static void sendRecordAsync(Application app, BloodPressureRecord record, String eventType) {&#10;        sendRecordAsync(app, record, eventType, null);&#10;    }&#10;&#10;    /**&#10;     * Envía el registro al webhook de n8n de forma asíncrona. &quot;eventType&quot; puede ser&#10;     * &quot;created&quot;, &quot;updated&quot; o &quot;deleted&quot;. Si se proporciona recommendation, se incluirá en el payload.&#10;     */&#10;    public static void sendRecordAsync(Application app, BloodPressureRecord record, String eventType, String recommendation) {&#10;        if (app == null || record == null) return;&#10;&#10;        String url = null;&#10;        try {&#10;            url = app.getString(R.string.n8n_webhook_url);&#10;        } catch (Exception ignored) {}&#10;&#10;        if (TextUtils.isEmpty(url)) {&#10;            Log.w(TAG, &quot;n8n_webhook_url vacío: no se enviará el evento&quot;);&#10;            return;&#10;        }&#10;        if (!NetworkUtils.isNetworkAvailable(app)) {&#10;            Log.w(TAG, &quot;Sin red: no se enviará el evento al webhook&quot;);&#10;            return;&#10;        }&#10;&#10;        // Construir payload&#10;        Payload payload = new Payload();&#10;        payload.event = eventType == null ? &quot;created&quot; : eventType.toLowerCase(Locale.getDefault());&#10;        payload.id = record.getId();&#10;        payload.date = record.getDate();&#10;        payload.time = record.getTime();&#10;        payload.systolic = record.getSystolic();&#10;        payload.diastolic = record.getDiastolic();&#10;        payload.heartRate = record.getHeartRate();&#10;        payload.classification = record.getClassification() != null ? record.getClassification() :&#10;                ClassificationHelper.classify(record.getSystolic(), record.getDiastolic());&#10;        payload.condition = record.getCondition();&#10;        payload.recommendation = (recommendation == null ? null : recommendation.trim());&#10;        try { payload.userName = SessionManager.getUserName(app); } catch (Exception ignored) {}&#10;&#10;        String body = gson.toJson(payload);&#10;        RequestBody requestBody = RequestBody.create(body, JSON);&#10;        Request request = new Request.Builder()&#10;                .url(url)&#10;                .post(requestBody)&#10;                .build();&#10;&#10;        client.newCall(request).enqueue(new Callback() {&#10;            @Override&#10;            public void onFailure(Call call, IOException e) {&#10;                Log.e(TAG, &quot;Error enviando a n8n: &quot; + e.getMessage());&#10;            }&#10;&#10;            @Override&#10;            public void onResponse(Call call, Response response) throws IOException {&#10;                try (Response r = response) {&#10;                    if (!r.isSuccessful()) {&#10;                        Log.e(TAG, &quot;Webhook n8n HTTP &quot; + r.code() + &quot;: &quot; + (r.body() != null ? r.body().string() : &quot;&quot;));&#10;                    } else {&#10;                        Log.d(TAG, &quot;Evento enviado a n8n OK: &quot; + payload.event + &quot; (#&quot; + record.getId() + &quot;)&quot;);&#10;                    }&#10;                }&#10;            }&#10;        });&#10;    }&#10;&#10;    // POJO de payload&#10;    static class Payload {&#10;        @SerializedName(&quot;event&quot;) String event;&#10;        @SerializedName(&quot;id&quot;) long id;&#10;        @SerializedName(&quot;date&quot;) String date;&#10;        @SerializedName(&quot;time&quot;) String time;&#10;        @SerializedName(&quot;systolic&quot;) int systolic;&#10;        @SerializedName(&quot;diastolic&quot;) int diastolic;&#10;        @SerializedName(&quot;heartRate&quot;) int heartRate;&#10;        @SerializedName(&quot;classification&quot;) String classification;&#10;        @SerializedName(&quot;condition&quot;) String condition;&#10;        @SerializedName(&quot;userName&quot;) String userName;&#10;        @SerializedName(&quot;recommendation&quot;) String recommendation;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.proyectopresionarterial;&#10;&#10;import android.app.Application;&#10;import android.text.TextUtils;&#10;import android.util.Log;&#10;&#10;import com.google.gson.Gson;&#10;import com.google.gson.annotations.SerializedName;&#10;&#10;import java.util.Locale;&#10;&#10;import okhttp3.Call;&#10;import okhttp3.Callback;&#10;import okhttp3.MediaType;&#10;import okhttp3.OkHttpClient;&#10;import okhttp3.Request;&#10;import okhttp3.RequestBody;&#10;import okhttp3.Response;&#10;import java.io.IOException;&#10;&#10;/**&#10; * Cliente minimalista para enviar eventos al webhook de n8n.&#10; * Configurar en res/values/strings.xml el valor de n8n_webhook_url con el link del webhook.&#10; * Alternativamente, definir N8N_WEBHOOK_URL en gradle.properties (BuildConfig) para sobrescribir.&#10; */&#10;public final class N8nWebhookClient {&#10;&#10;    private static final String TAG = &quot;N8nWebhook&quot;;&#10;    private static final MediaType JSON = MediaType.parse(&quot;application/json; charset=utf-8&quot;);&#10;&#10;    private static final OkHttpClient client = new OkHttpClient.Builder()&#10;            .retryOnConnectionFailure(true)&#10;            .build();&#10;&#10;    private static final Gson gson = new Gson();&#10;&#10;    private N8nWebhookClient() {}&#10;&#10;    /**&#10;     * Compatibilidad hacia atrás: envía sin recomendación.&#10;     */&#10;    public static void sendRecordAsync(Application app, BloodPressureRecord record, String eventType) {&#10;        sendRecordAsync(app, record, eventType, null);&#10;    }&#10;&#10;    /**&#10;     * Envía el registro al webhook de n8n de forma asíncrona. &quot;eventType&quot; puede ser&#10;     * &quot;created&quot;, &quot;updated&quot; o &quot;deleted&quot;. Si se proporciona recommendation, se incluirá en el payload.&#10;     */&#10;    public static void sendRecordAsync(Application app, BloodPressureRecord record, String eventType, String recommendation) {&#10;        if (app == null || record == null) return;&#10;&#10;        String url = null;&#10;        try {&#10;            // 1) Preferir URL desde BuildConfig (gradle.properties)&#10;            String cfg = BuildConfig.N8N_WEBHOOK_URL;&#10;            if (!TextUtils.isEmpty(cfg)) {&#10;                url = cfg.trim();&#10;            }&#10;            // 2) Fallback a resources si BuildConfig está vacío&#10;            if (TextUtils.isEmpty(url)) {&#10;                url = app.getString(R.string.n8n_webhook_url);&#10;                if (!TextUtils.isEmpty(url)) url = url.trim();&#10;            }&#10;        } catch (Exception ignored) {}&#10;&#10;        if (TextUtils.isEmpty(url)) {&#10;            Log.w(TAG, &quot;n8n_webhook_url vacío: no se enviará el evento&quot;);&#10;            return;&#10;        }&#10;        if (!NetworkUtils.isNetworkAvailable(app)) {&#10;            Log.w(TAG, &quot;Sin red: no se enviará el evento al webhook&quot;);&#10;            return;&#10;        }&#10;&#10;        // Construir payload&#10;        Payload payload = new Payload();&#10;        payload.event = eventType == null ? &quot;created&quot; : eventType.toLowerCase(Locale.getDefault());&#10;        payload.id = record.getId();&#10;        payload.date = record.getDate();&#10;        payload.time = record.getTime();&#10;        payload.systolic = record.getSystolic();&#10;        payload.diastolic = record.getDiastolic();&#10;        payload.heartRate = record.getHeartRate();&#10;        payload.classification = record.getClassification() != null ? record.getClassification() :&#10;                ClassificationHelper.classify(record.getSystolic(), record.getDiastolic());&#10;        payload.condition = record.getCondition();&#10;        payload.recommendation = (recommendation == null ? null : recommendation.trim());&#10;        try { payload.userName = SessionManager.getUserName(app); } catch (Exception ignored) {}&#10;&#10;        String body = gson.toJson(payload);&#10;        RequestBody requestBody = RequestBody.create(body, JSON);&#10;        Request request = new Request.Builder()&#10;                .url(url)&#10;                .post(requestBody)&#10;                .build();&#10;&#10;        Log.d(TAG, &quot;Enviando evento '&quot; + payload.event + &quot;' al webhook: &quot; + url + &quot; (id=&quot; + record.getId() + &quot;)&quot;);&#10;&#10;        client.newCall(request).enqueue(new Callback() {&#10;            @Override&#10;            public void onFailure(Call call, IOException e) {&#10;                Log.e(TAG, &quot;Error enviando a n8n: &quot; + e.getMessage());&#10;            }&#10;&#10;            @Override&#10;            public void onResponse(Call call, Response response) throws IOException {&#10;                try (Response r = response) {&#10;                    if (!r.isSuccessful()) {&#10;                        Log.e(TAG, &quot;Webhook n8n HTTP &quot; + r.code() + &quot;: &quot; + (r.body() != null ? r.body().string() : &quot;&quot;));&#10;                    } else {&#10;                        Log.d(TAG, &quot;Evento enviado a n8n OK: &quot; + payload.event + &quot; (#&quot; + record.getId() + &quot;)&quot;);&#10;                    }&#10;                }&#10;            }&#10;        });&#10;    }&#10;&#10;    // POJO de payload&#10;    static class Payload {&#10;        @SerializedName(&quot;event&quot;) String event;&#10;        @SerializedName(&quot;id&quot;) long id;&#10;        @SerializedName(&quot;date&quot;) String date;&#10;        @SerializedName(&quot;time&quot;) String time;&#10;        @SerializedName(&quot;systolic&quot;) int systolic;&#10;        @SerializedName(&quot;diastolic&quot;) int diastolic;&#10;        @SerializedName(&quot;heartRate&quot;) int heartRate;&#10;        @SerializedName(&quot;classification&quot;) String classification;&#10;        @SerializedName(&quot;condition&quot;) String condition;&#10;        @SerializedName(&quot;userName&quot;) String userName;&#10;        @SerializedName(&quot;recommendation&quot;) String recommendation;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/proyectopresionarterial/RecommendationLocal.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/proyectopresionarterial/RecommendationLocal.java" />
              <option name="updatedContent" value="package com.example.proyectopresionarterial;&#10;&#10;import android.text.TextUtils;&#10;&#10;import java.util.Locale;&#10;&#10;/** Genera una recomendación breve (2-3 frases) según la medición actual. */&#10;public final class RecommendationLocal {&#10;&#10;    private RecommendationLocal() {}&#10;&#10;    public static String generate(BloodPressureRecord r) {&#10;        if (r == null) return null;&#10;        String classification;&#10;        try {&#10;            classification = r.getClassification();&#10;            if (TextUtils.isEmpty(classification)) {&#10;                classification = ClassificationHelper.classify(r.getSystolic(), r.getDiastolic());&#10;            }&#10;        } catch (Exception e) {&#10;            classification = &quot;normal&quot;;&#10;        }&#10;        return generate(r.getSystolic(), r.getDiastolic(), r.getHeartRate(), r.getCondition(), classification);&#10;    }&#10;&#10;    public static String generate(int systolic, int diastolic, int heartRate, String condition, String classification) {&#10;        String cls = classification == null ? &quot;&quot; : classification.toLowerCase(Locale.getDefault());&#10;        String cond = condition == null ? &quot;&quot; : condition.toLowerCase(Locale.getDefault());&#10;&#10;        boolean crisis = systolic &gt;= 180 || diastolic &gt;= 120;&#10;        boolean tachy = heartRate &gt; 100;&#10;        boolean brady = heartRate &gt; 0 &amp;&amp; heartRate &lt; 50;&#10;&#10;        StringBuilder sb = new StringBuilder();&#10;&#10;        if (crisis) {&#10;            sb.append(&quot;Tus valores (&quot; + systolic + &quot;/&quot; + diastolic + &quot; mmHg) sugieren una urgencia. Busca atención médica inmediata si presentas síntomas como dolor de cabeza intenso, dolor torácico, dificultad para respirar o visión borrosa.&quot;);&#10;            sb.append(&quot; En lo posible, repite la medición tras 5 minutos de reposo y evita esfuerzos.&quot;);&#10;            return sb.toString();&#10;        }&#10;&#10;        if (cls.contains(&quot;normal&quot;)) {&#10;            sb.append(&quot;Tus valores (&quot; + systolic + &quot;/&quot; + diastolic + &quot; mmHg) están dentro de lo normal. Mantén hábitos saludables: limita la sal, realiza actividad física regular y duerme bien.&quot;);&#10;            sb.append(&quot; Controla tu presión periódicamente para dar seguimiento.&quot;);&#10;        } else if (cls.contains(&quot;elevad&quot;)) { // 'elevada'&#10;            sb.append(&quot;Tu presión (&quot; + systolic + &quot;/&quot; + diastolic + &quot; mmHg) está ligeramente elevada. Refuerza cambios de estilo de vida: reduce sal, cuida el peso y aumenta la actividad física.&quot;);&#10;            sb.append(&quot; Repite mediciones en días distintos; si persiste por 2-3 semanas, consulta con tu médico.&quot;);&#10;        } else if (cls.contains(&quot;estadio 1&quot;) || cls.contains(&quot;hipertensión estadio 1&quot;) || cls.contains(&quot;hipertension 1&quot;)) {&#10;            sb.append(&quot;Tus valores sugieren hipertensión estadio 1. Prioriza cambios de estilo de vida (menos sal, ejercicio, control de peso) y monitoriza 3-4 veces por semana.&quot;);&#10;            sb.append(&quot; Agenda una consulta médica para evaluación y plan de seguimiento.&quot;);&#10;        } else if (cls.contains(&quot;estadio 2&quot;) || cls.contains(&quot;hipertensión estadio 2&quot;) || cls.contains(&quot;hipertension 2&quot;)) {&#10;            sb.append(&quot;Tus valores indican hipertensión estadio 2. Es recomendable consultar con tu médico pronto para ajustar el plan de tratamiento.&quot;);&#10;            sb.append(&quot; Mientras tanto, reduce la sal, evita alcohol en exceso y monitoriza con mayor frecuencia.&quot;);&#10;        } else {&#10;            // Desconocido: recomendar prudencia&#10;            sb.append(&quot;Con estos valores (&quot; + systolic + &quot;/&quot; + diastolic + &quot; mmHg) se sugiere reforzar hábitos saludables y repetir la medición en reposo.&quot;);&#10;            sb.append(&quot; Si se mantienen elevados, consulta con tu médico.&quot;);&#10;        }&#10;&#10;        if (!cond.isEmpty()) {&#10;            if (cond.contains(&quot;ejercicio&quot;) || cond.contains(&quot;actividad&quot;)) {&#10;                sb.append(&quot; Como fue tras ejercicio, repite la medición en reposo para comparar.&quot;);&#10;            } else if (cond.contains(&quot;estrés&quot;) || cond.contains(&quot;estres&quot;)) {&#10;                sb.append(&quot; Considera técnicas de manejo de estrés (respiración, pausas activas).&quot;);&#10;            }&#10;        }&#10;&#10;        if (tachy) {&#10;            sb.append(&quot; Nota: la frecuencia cardíaca es alta (&quot; + heartRate + &quot; bpm). Si persiste, consulta.&quot;);&#10;        } else if (brady) {&#10;            sb.append(&quot; Nota: la frecuencia cardíaca es baja (&quot; + heartRate + &quot; bpm). Si presentas mareos o malestar, consulta.&quot;);&#10;        }&#10;&#10;        return sb.toString();&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>